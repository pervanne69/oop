from typing import List, Dictdef depth_first_search(node: int, nodes: List[Dict],                       flags: List[bool]) -> bool:    """    Perform a depth-first search to determine winning moves.    :param node: (int) The current node (airport) being visited.    :param nodes: (List[Dict]) List of nodes representing airports.    :param flags: (List[bool]) List of boolean values    indicating winning moves.    :return bool: True if the starting player can win from this node,    False otherwise.    """    nodes[node]['visited'] = True    win = False    for neighbor in nodes[node]['neighbors']:        if not nodes[neighbor]['visited']:            if not depth_first_search(neighbor, nodes, flags):                win = True    flags[node] = win    return windef main() -> None:    """    Main function to read input,    initialize data structures,    and determine the game's outcome based on optimal moves.    :return None:    """    n, k = map(int, input().split())    nodes = [{'neighbors': [], 'visited': False} for _ in range(n + 1)]    flags = [False] * (n + 1)    for _ in range(n - 1):        x, y = map(int, input().split())        nodes[x]['neighbors'].append(y)        nodes[y]['neighbors'].append(x)    nodes[k]['visited'] = True    min_airport = n + 1    for neighbor in nodes[k]['neighbors']:        if not depth_first_search(neighbor, nodes, flags):            min_airport = min(min_airport, neighbor)    if min_airport != n + 1:        print(f"First player wins flying to airport {min_airport}")    else:        print("First player loses")if __name__ == "__main__":    main()