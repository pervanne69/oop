class Point:    """    Represents a point in 2D space.    """    def __init__(self, x=0, y=0):        """        Initializes a Point object.        :param x: The x-coordinate of the point.        :param y: The y-coordinate of the point.        """        self.x = x        self.y = y    def __sub__(self, p):        """        Subtracts the coordinates of another point        from this point and returns a new Point object.        :param p: The other point to subtract.        :return: A new Point object representing the difference.        """        return Point(self.x - p.x, self.y - p.y)    def cross_product(self, p) -> int:        """        Calculates the cross product of this point with another point.        :param p: The other point.        :return: The cross product of the two points.        """        return self.x * p.y - self.y * p.xclass Node:    """    Represents a node in the graph.    """    def __init__(self, p):        """        Initializes a Node object.        :param p: The point associated with this node.        """        self.p = p        self.visited = False        self.neighbors = []def straddles(u, v1, v2) -> bool:    """    Checks if point v is on the line segment between u1 and u2.    :param u: The point representing one end of the line segment.    :param v1: The point representing the other end of the line segment.    :param v2: The point to check.    :return: True if point v is on the line segment between u1 and u2    False otherwise.    """    v1_cr_pr = u.cross_product(v1)    v2_cr_pr = u.cross_product(v2)    return ((v1_cr_pr >= 0 >= v2_cr_pr or v1_cr_pr <= 0 <= v2_cr_pr) and            (v1_cr_pr != 0 or v2_cr_pr != 0))def intersect(u1, u2, v) -> bool:    """    Checks if two line segments intersect.    :param u1: The first point of the first line segment.    :param u2: The second point of the first line segment.    :param v: The point to check for intersection with the line segment.    :return: True if the line segment [u1, u2] intersects with point v    False otherwise.    """    return ((u2 - u1).            cross_product(v - u1) == 0 and            u1.x <= v.x <= u2.x and u1.y <= v.y <= u2.y)def segment_intersect(u1, u2, v1, v2) -> bool:    """    Checks if two line segments intersect.    :param u1: The first point of the first line segment.    :param u2: The second point of the first line segment.    :param v1: The first point of the second line segment.    :param v2: The second point of the second line segment.    :return: True if the line segments [u1, u2] and [v1, v2] intersect    False otherwise.    """    return (straddles(u2 - u1, v1 - u1, v2 - u1) and            straddles(v2 - v1, u1 - v1, u2 - v1))def connect(node1, node2):    """    Connects two nodes in the graph.    :param node1: The first node.    :param node2: The second node.    """    A[node1][node2] = A[node2][node1] = Truedef dfs(node):    """    Performs depth-first search starting from a given node.    :param node: The starting node for the depth-first search.    """    node.visited = True    for neighbor in node.neighbors:        if not neighbor.visited:            dfs(neighbor)n, m = map(int, input().split())nodes = [None] + [Node(Point(*map(int, input().split()))) for _ in range(n)]A = [[False] * (n + 1) for _ in range(n + 1)]lines = []for _ in range(m):    i, j = map(int, input().split())    connect(i, j)    for line in lines:        a, b = line        if segment_intersect(a.p, b.p, nodes[i].p, nodes[j].p):            connect(lines.index(line) + 1, i)            connect(lines.index(line) + 1, j)    for k in range(1, n + 1):        if intersect(nodes[i].p, nodes[j].p, nodes[k].p):            connect(i, k)            connect(j, k)    lines.append((nodes[i], nodes[j]))for i in range(1, n + 1):    for j in range(1, n + 1):        if A[i][j] and i != j:            nodes[i].neighbors.append(nodes[j])dfs(nodes[1])print("YES" if all(node.visited for node in nodes[1:]) else "NO")