class Point:    """    Represents a point in 2D space.    """    def __init__(self, x: int = 0, y: int = 0):        """        Initialize a Point object with coordinates (x, y).        :param x: (int) The x-coordinate of the point (default is 0).        :param y: (int) The y-coordinate of the point (default is 0).        """        self.x = x        self.y = y    def __sub__(self, other):        """        Subtract another Point from this Point.        :param other: (Point) The other Point to subtract.        :return Point: The resulting Point after subtraction.        """        return Point(self.x - other.x, self.y - other.y)    def cross_product(self, other) -> int:        """        Calculate the cross product of this Point and another Point.        :param other: (Point) The other Point for cross product calc.        :return int: The cross product value.        """        return self.x * other.y - self.y * other.xdef straddles(u, v1, v2) -> bool:    """    Check if two vectors form a convex polygon.    :param u: (Point) The base vector.    :param v1: (Point) The first vector.    :param v2: (Point) The second vector.    :return bool: True if the vectors form polygon, False otherwise.    """    a_c = u.cross_product(v1)    b_c = u.cross_product(v2)    return (a_c >= 0 >= b_c or a_c <= 0 <= b_c) and (a_c != 0 or b_c != 0)def intersect(u1, u2, v) -> bool:    """    Check if a point lies on the line segment.    :param u1: (Point) The start point of the line segment.    :param u2: (Point) The end point of the line segment.    :param v: (Point) The point to check.    :return bool: True if the point on the line segment, False instead.    """    return (u2 - u1).cross_product(v - u1) == 0 and \        min(u1.x, u2.x) <= v.x <= max(u1.x, u2.x) and \        min(u1.y, u2.y) <= v.y <= max(u1.y, u2.y)def intersect_segments(u1, u2, v1, v2) -> bool:    """    Check if line segments intersect.    :param u1: (Point) The start point of the first line segment.    :param u2: (Point) The end point of the first line segment.    :param v1: (Point) The start point of the second line segment.    :param v2: (Point) The end point of the second line segment.    :return bool: True if line segments intersect, False otherwise.    """    return straddles(u2 - u1, v1 - u1, v2 - u1) and \        straddles(v2 - v1, u1 - v1, u2 - v1)class Node:    """    Represents a node in the graph.    Attributes:        p (Point): The coordinates of the node.        visited (bool): Indicates if the node has been visited.        neighbors (list): List of neighboring nodes.    """    def __init__(self, p):        """        Initialize a Node object with a Point.        :param p: (Point) The coordinates of the node.        """        self.p = p        self.visited = False        self.neighbors = []def connect(f_index: int, s_index: int):    """    Connect two nodes in the graph.    :param f_index: (int) Index of the first node.    :param s_index: (int) Index of the second node.    :return:    """    lst[f_index][s_index] = lst[s_index][f_index] = Truedef dfs(node):    """    Perform depth-first search on the graph.    :param node: (Node) The starting node for DFS.    :return:    """    node.visited = True    for neighbor in node.neighbors:        if not neighbor.visited:            dfs(neighbor)# Main programn, m = map(int, input().split())nodes = [None] + [Node(Point(*map(int, input().split()))) for _ in range(n)]lst = [[False] * (n + 1) for _ in range(n + 1)]lines = []for _ in range(m):    i, j = map(int, input().split())    connect(i, j)    for a, b in lines:        if intersect_segments(a.p, b.p, nodes[i].p, nodes[j].p):            ai, bi = nodes.index(a), nodes.index(b)            lst[ai][i] = lst[i][ai] = lst[bi][i] = lst[i][bi] = True            lst[ai][j] = lst[j][ai] = lst[bi][j] = lst[j][bi] = True    for k in range(1, n + 1):        if intersect(nodes[i].p, nodes[j].p, nodes[k].p):            lst[i][k] = lst[k][i] = lst[j][k] = lst[k][j] = True    lines.append((nodes[i], nodes[j]))for i in range(1, n + 1):    for j in range(1, n + 1):        if lst[i][j] and i != j:            nodes[i].neighbors.append(nodes[j])dfs(nodes[1])print("YES" if all(node.visited for node in nodes[1:]) else "NO")