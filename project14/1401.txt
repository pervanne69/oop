class GameTiler:    def __init__(self, n: int, missing_x: int, missing_y: int) -> None:        """        Initialize the Tiler with the board size and        the missing cell coordinates.        :param n: (int) The exponent to determine the board size        :param missing_x: (int) The x-coordinate of the missing cell        :param missing_y: (int) The y-coordinate of the missing cell        """        self.size = 2 ** n        self.board = [[0] * self.size for _ in range(self.size)]        self.current_id = 1        self.tile(self.size, 0, 0, missing_x - 1, missing_y - 1)        self.board[missing_x - 1][missing_y - 1] = 0    def tile(self, size: int, top_x: int, top_y: int, missing_x: int,             missing_y: int) -> None:        """        Recursively tile the sub_board.        :param size: (int) The size of the current sub-board.        :param top_x: (int) The top-left x-coordinate of sub-board.        :param top_y: (int) The top-left y-coordinate of sub-board.        :param missing_x: (int) The x-coordinate of the        missing cell in sub-board.        :param missing_y: (int) The y-coordinate of the        missing cell in  sub-board.        :return None:        """        if size == 2:            id_to_place = self.current_id            self.current_id += 1            for i in range(2):                for j in range(2):                    if top_x + i != missing_x or top_y + j != missing_y:                        self.board[top_x + i][top_y + j] = id_to_place            return        half_size = size // 2        centers = [            (top_x + half_size - 1, top_y + half_size - 1),            (top_x + half_size - 1, top_y + half_size),            (top_x + half_size, top_y + half_size - 1),            (top_x + half_size, top_y + half_size)        ]        quadrant_with_hole = -1        for i, (_, __) in enumerate(centers):            if top_x + (i // 2) * half_size <= missing_x < top_x + (                    i // 2 + 1) * half_size and \                    top_y + (i % 2) * half_size <= missing_y < top_y + (                    i % 2 + 1) * half_size:                quadrant_with_hole = i                break        for i, (cx, cy) in enumerate(centers):            if i != quadrant_with_hole:                self.board[cx][cy] = self.current_id        self.current_id += 1        for i in range(4):            new_top_x = top_x + (i // 2) * half_size            new_top_y = top_y + (i % 2) * half_size            new_missing_x, new_missing_y = centers[                i] if i != quadrant_with_hole else (missing_x, missing_y)            self.tile(half_size, new_top_x, new_top_y, new_missing_x,                      new_missing_y)    def print_board(self) -> None:        """        Print the current state of the board.        :return None:        """        for row in self.board:            print(" ".join(map(str, row)))def main() -> None:    """    Main function to read input, create a    GameTiler instance, and print the board.    """    n = int(input())    x, y = map(int, input().split())    tiler = GameTiler(n, x, y)    tiler.print_board()if __name__ == "__main__":    main()